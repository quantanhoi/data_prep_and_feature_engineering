:jbake-title: Pandas
:jbake-type: page_toc
:jbake-status: published
:jbake-menu: arc42
:jbake-order: 1
:filename: /chapters/01_pandas.adoc
ifndef::imagesdir[:imagesdir: ../../images]

:toc:



[[section-building-block-view]]


== Pandas

=== Data Access & Select

This document outlines common pandas functions for selecting and inspecting data, mirroring the style used in *03_scaling_numerical.adoc*. Use it as a quick reference for exploring and manipulating DataFrames.





==== df.head()
.Shows the first few rows of a DataFrame.
[source,python]
----
import pandas as pd

df = pd.DataFrame({
    'Name': ['Alice', 'Bob', 'Charlie'],
    'Age': [25, 30, 35]
})

print(df.head())  # By default, shows first 5 rows
----
*When to Use:*  
- Quickly inspect the top of a dataset to verify columns, data types, and sample records.

*When Not to Use:*  
- Large-scale data exploration beyond the first few rows.





==== df.tail()
.Shows the last few rows of a DataFrame.
[source,python]
----
import pandas as pd

df = pd.DataFrame({
    'Name': ['Alice', 'Bob', 'Charlie', 'Diana', 'Ethan'],
    'Score': [88, 92, 79, 85, 90]
})

print(df.tail(2))  # Shows the last 2 rows
----
*When to Use:*  
- Check recent rows, e.g., last few records in a time series.

*When Not to Use:*  
- Full data inspection or large-scale analysis.





==== df.describe()
.Provides summary statistics for numeric columns.
[source,python]
----
import pandas as pd

df = pd.DataFrame({
    'col1': [10, 20, 30],
    'col2': [5, 10, 15]
})

print(df.describe())
----
*When to Use:*  
- Get quick insight into count, mean, standard deviation, etc.

*When Not to Use:*  
- Investigating non-numeric columns in detail (it wonâ€™t summarize strings).


==== df.sort_index()
.Sorts a DataFrame by its index.
[source,python]
----
import pandas as pd
df = pd.DataFrame({
    'Name': ['Charlie', 'Bob', 'Alice'],
    'Age': [35, 30, 25]
}, index=[2, 1, 0])

sorted_df = df.sort_index()
print(sorted_df)
----
*When to Use:*
- When you need to order data based on the DataFrame's index.
- Useful for time series data or when the index is meaningful.
*When Not to Use:*
- When you need to sort by a specific column instead of the index; use `df.sort_values()` instead.




==== df.sort_values('col')
.Sorts a DataFrame by a specified column.
[source,python]
----
import pandas as pd

df = pd.DataFrame({
    'Name': ['Charlie', 'Bob', 'Alice'],
    'Age': [35, 30, 25]
})

sorted_df = df.sort_values('Age')
print(sorted_df)
----
*When to Use:*  
- Order data for better readability or to prepare for merges/joins.

*When Not to Use:*  
- Data that is too large for in-memory sorting.




==== .loc[row, col]
.Label-based data selection.
[source,python]
----
import pandas as pd

df = pd.DataFrame({
    'City': ['Paris', 'London', 'Berlin', 'London'],
    'Population': [2148271, 8982000, 3645000, 1234567]
})
# loc is label-based
pop_london = df.loc[df['City'] == 'London', 'Population']
print(pop_london)

# or you can use a mask with .loc
mask = df['City'].eq('London')
pop_london_mask = df.loc[mask, 'Population']
print(pop_london_mask)

----

Output:
[source,python]
----
1    8982000
3    1234567
Name: Population, dtype: int64
----

.How it works:
Loc parses its two arguments as follows:
* .loc sees a boolean array on the first axis, keeps all rows whose mask element is True, and then returns the Population column of those rows.
Example:
* 0 False
* 1 True
* 2 False


*When to Use:*  
- Selecting rows and columns by labels or boolean conditions.

*When Not to Use:*  
- Pure index-based selection; use .iloc instead.

==== .iloc[row, col]
.Index-based (positional) data selection.
[source,python]
----
import pandas as pd

df = pd.DataFrame({
    'City': ['Paris', 'London', 'Berlin', 'London'],
    'Population': [2148271, 8982000, 3645000, 1234567]
})

#iloc is index-based
pop_london_iloc = df.iloc[2, :]  # 0 is index of city, 1 is index of population, use : to select all columns
print(pop_london_iloc)
----
.Output:
[source,python]
----
City           Berlin
Population    3645000
Name: 2, dtype: object
----
.Or if you want to make it the same as .loc where it returns all the rows that passed the condition:
[source,python]
----
# convert the column label to its positional index
pop_idx = df.columns.get_loc('Population')
# Alternatively, to use .iloc, convert the mask to integer positions:
row_indices = mask[mask].index
# same rows/column as your .loc version
pop_london = df.iloc[row_indices, pop_idx]
print(pop_london)
----
.Output:
[source,python]
----
1    8982000
3    1234567
Name: Population, dtype: int64
----



*When to Use:*  
- Access by integer positions (like array indexing).

*When Not to Use:*  
- Selecting by label or condition; use .loc instead.

==== .at[row, col]
.Fast label-based single value access.
[source,python]
----
import pandas as pd

df = pd.DataFrame({
    'Key': ['item1', 'item2'],
    'Price': [10.99, 8.75]
})

val = df.at[1, 'Price']
print(val)
----
*When to Use:*  
- Optimized for retrieving a single value at known row and column labels.

*When Not to Use:*  
- Selecting multiple rows or columns at once.

==== .iat[row, col]
.Fast index-based single value access.
[source,python]
----
import pandas as pd

df = pd.DataFrame({
    'Key': ['item1', 'item2'],
    'Price': [10.99, 8.75]
})

val = df.iat[1, 1]
print(val)
----
*When to Use:*  
- Optimized for retrieving a single value at known row and column positions.

*When Not to Use:*  
- Selecting by label or for retrieving multiple values.
